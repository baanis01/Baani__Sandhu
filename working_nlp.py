# -*- coding: utf-8 -*-
"""working_nlp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1koEaMFWkT7cxD1DABS2OQ59YKMKNgrAS

INSTALLATIONS
"""

!pip install kagglehub

"""IMPORTS"""

import kagglehub
import pandas as pd
import numpy as np
import re
import os

"""GETTING EMAILS FROM A KAGGLE DATASET"""

data = kagglehub.dataset_download("chandramoulinaidu/spam-classification-for-basic-nlp")

csv_file = os.path.join(data,"Spam Email raw text for NLP.csv")

df1 = pd.read_csv(csv_file)

# print(df.head())

df = df1["MESSAGE"]
kaggle_df =df.astype(str)

print(len(kaggle_df))

"""SOME SAMPLE EMAIL TXT FILES IN A DIRECTORY("my_email_data")"""

import os

directory_name = 'my_email_data'


if not os.path.exists(directory_name):
    os.makedirs(directory_name)
    print(f"Directory '{directory_name}' created successfully.")
else:
    print(f"Directory '{directory_name}' already exists.")

os.listdir("my_email_data")

with open("my_email_data/email1.txt","wt") as e1:
  e1.write('''Subject: We’re Sorry for the Inconvenience – Here’s How We’re Fixing It

To: baanisandhu22@gmail.com

Dear Baani,

Thank you for bringing this to our attention. I’m truly sorry to hear about the issue you experienced with the Jio Chatbot. I completely understand how frustrating this must have been for you.

Our team has already investigated the matter and identified the cause. We’ve taken the following steps to resolve it:

We have made sure it has access to all the updates information and does not give outdated misonformation.
As a gesture of goodwill, we’d like to offer you 3 months of free JioSaavn to make up for the inconvenience.

Please let me know if everything is now working as expected, or if there’s anything else we can do to help.

Warm regards,

Mr Dhruva
Data Scientist
Jio''')

with open("my_email_data/email2.txt","xt") as e2:
  e2.write('''Subject: Comfort, Protection & Confidence – Sanitary Pads Your Customers Will Love

To: Dhruv@gmail.com

Dear Dhruv,

I hope this message finds you well. I’m reaching out to introduce our premium range of sanitary pads designed to deliver exceptional comfort, reliable protection, and the confidence women deserve every day.

Our products are crafted with ultra-soft, skin-friendly materials, advanced absorption technology, and leak-lock protection to ensure all-day freshness. Whether for daily retail sales or bulk distribution, our sanitary pads are available in multiple sizes and packaging options to suit diverse customer needs.

Key Highlights:

Ultra-thin yet highly absorbent for maximum comfort
Rash-free, breathable top sheet for sensitive skin
Secure fit with anti-leak channels
Affordable pricing with attractive bulk order discounts
We are currently offering special introductory rates for first-time bulk orders, along with free samples so you can experience the quality firsthand before committing.

Would you be open to a quick call this week to discuss how our products can add value to your portfolio and meet your customers’ needs?

Looking forward to your response.

Warm regards,

Mr. Karan
Marketing Head
Stayfree Ltd.''')

with open("my_email_data/email3.txt","xt") as e3:
  e3.write('''Subject: Supply Chain Update – Week] Highlights

Hi Team,

I hope you’re all doing well. Here’s a quick update on our supply chain operations:

1. Inventory Status

Current stock levels are stable for all key SKUs.
Safety stock for anitary pads has been replenished ahead of schedule.
2. Supplier Updates

Ms. Siddhi confirmed on-time delivery for the next shipment.
We’re monitoring potential delays from Ganganagar due to heavy rainfall.
3. Process Improvements

New barcode scanning system will go live on 26 December 2025 to speed up warehouse operations.
Please complete the short training module by 20-12-2025.
4. Action Items

Submit any urgent purchase requests by 18/12/2025.
Share feedback on the new order tracking dashboard.
Thank you for your continued dedication and teamwork. Our smooth operations are possible because of your efforts and attention to detail.

Best regards,

Mr. Piyush Sehwal

Supply Chain Manager

Walmart Co.''')

with open("my_email_data/email4.txt","xt") as e4:
  e4.write('''Subject: Payment Due Reminder – Credit Card Account

To: sneha@hotmail.com

Dear Sneha,

This is a friendly reminder that your credit card payment is due on 20-01-26. As of today, your outstanding balance is ₹4456.

To avoid late payment charges and interest, please ensure that your payment is made on or before the due date. You can make the payment conveniently through:

Net Banking / Mobile Banking
UPI / Debit Card
Auto-Debit Facility (if registered)
Account Summary:

Card Number: XXXX-XXXX-XXXX-3456
Statement Date: 10-01-26
Minimum Amount Due: ₹400
Total Amount Due: ₹4456
Due Date: 20-01-2026
If you have already made the payment, please disregard this message.

For any queries or assistance, feel free to contact our customer care at 1014-2256-9876 or email us at support@hdfc.com.

Thank you for your prompt attention to this matter.

Best regards,

Srishti
Branch Manager
HDFC Bank''')

with open("my_email_data/email5.txt","xt") as e5:
  e5.write('''Subject: Urgent: Verify Your Bank Account Information to Avoid Service Suspension

To: harmeharsingh@gmail.com

Dear Valued Customer,

We have detected unusual activity on your account and, for your security, we have temporarily limited certain services. To restore full access, we require you to verify your account information immediately.

Please confirm your details by clicking the secure link below:

[Verify My Account Now]

Failure to complete verification within 24 hours may result in permanent suspension of your account.

For your convenience, please have the following information ready:

Full Name
Account Number
Sort Code / IFSC Code
Date of Birth
Registered Mobile Number
We appreciate your prompt attention to this matter and thank you for banking with us.

Sincerely,

Account Security Department

HFDC Bank''')

import os
import pandas as pd

def load_emails_from_directory(directory_path):
    email_contents = []
    for filename in os.listdir(directory_path):
        file_path = os.path.join(directory_path, filename)
        if os.path.isfile(file_path) and filename.endswith('.txt'):
            with open(file_path, 'r', encoding='utf-8') as f:
                email_contents.append(f.read())
    return pd.Series(email_contents)

txtdf=load_emails_from_directory("my_email_data")
txtdf=txtdf.astype(str)
print(txtdf)

"""API KEY IN ENV"""

from google.colab import userdata
api_key = "userdata.get("GEMINI_API_KEY_1")"

"""MAIN LLM FUNCTION"""

!pip install -U langchain-google-genai

from langchain_google_genai import ChatGoogleGenerativeAI

import time

class output:
  def __init__(self, df, api_key):
    self.df = df
    self.llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash", temperature=0.5, google_api_key=api_key)
    self.entities = []
    self.labels = []
    self.summaries = []

  def preprocess(self):
    self.df = self.df.str.lower()
    self.df = self.df.str.replace(r'\s+', ' ', regex=True)
    return self.df

  def extract_entities(self):
    for idx, raw_text in enumerate(self.df):
      if idx >= 3:
        break
      prompt = (f'''
        You are a smart entity extractor. You will be given a string of raw email text: {raw_text}. From that, you have to extract entities.
        You can extract the following entities:
        - dates (make sure they are not time periods(example:45 minutes); they have to be dates)
        - email addresses
        - links
        - names
        Return the extracted entities in a JSON format with keys as entity types (dates, email_addresses, links, names) and values as lists of extracted entities. If no entities of a type are found, return an empty list for that key.
      ''')

      response = self.llm.invoke(prompt)
      self.entities.append({"email_text": raw_text, "extracted_entities": response}) # Storing raw_text
      time.sleep(0.05)


    return self.entities

  def text_classification(self):
    for idx, raw_text in enumerate(self.df):
      if idx >= 3: break
      prompt = (f'''
        You are a smart email classifier. You will be given a string of raw email text: {raw_text}. From that, you have to provide a classification label for the email.
        You can classify the email in the following categories:
        - Support
        - Sales
        - Internal
        - Notification
        - Spam
        Return the classification label in a 1-word string. Make sure the label is one of the categories above. No other text should be returned.
              ''')

      response = self.llm.invoke(prompt)
      self.labels.append({"email_text": raw_text, "label": response}) # Storing raw_text and label
      time.sleep(0.05)


    return self.labels

  def summarisation(self):
    for idx, raw_text in enumerate(self.df):
      if idx >= 3: break
      prompt = (f'''
        You are a smart email summariser. You will be given a string of raw email text: {raw_text}. From that, you have to provide a 2 or 3 line summary for the email.
        Instructions:
        - Make sure to include important details.
        - The summary should be not longer than 4 sentences and not shorter than 2 sentences.
        Return the summary in a string.
      ''')

      response = self.llm.invoke(prompt)
      self.summaries.append({"email_text": raw_text, "summary": response}) # Storing raw_text and summary
      time.sleep(0.05)


    return self.summaries

  def main(self):
    print("\n Preprocessing: ")
    preprocessed_df = self.preprocess()
    print("\n Extracting Entities: ")
    _ = self.extract_entities()
    print("\n Text Classification: ")
    _ = self.text_classification()
    print("\n Summarisation: ")
    _ = self.summarisation()

    entities_df = pd.DataFrame(self.entities)
    labels_df = pd.DataFrame(self.labels)
    summaries_df = pd.DataFrame(self.summaries)

    if not entities_df.empty and 'extracted_entities' in entities_df.columns:
      entities_df['extracted_entities'] = entities_df['extracted_entities'].apply(lambda x: x.content if hasattr(x, 'content') else str(x))
    if not labels_df.empty and 'label' in labels_df.columns:
      labels_df['label'] = labels_df['label'].apply(lambda x: x.content if hasattr(x, 'content') else str(x))
    if not summaries_df.empty and 'summary' in summaries_df.columns:
      summaries_df['summary'] = summaries_df['summary'].apply(lambda x: x.content if hasattr(x, 'content') else str(x))

    merged_df = entities_df
    if not labels_df.empty:
        merged_df = pd.merge(merged_df, labels_df, on='email_text', how='left')
    if not summaries_df.empty:
        merged_df = pd.merge(merged_df, summaries_df, on='email_text', how='left')

    return merged_df

sample_output = output(txtdf, api_key)
result =sample_output.main()
print(result)
result.to_csv('processed_emails.csv', index=False)
print("DataFrame successfully saved to processed_emails.csv")